execute_pipes(commands);
return values exit_flag

export variables ?

Command 0: echo
Command 1: $?



fred@fred-virtualbox:~/code/minishell/ajamshid$ ./minishell
minishell> ./minishell
Command 0:
  Arg 0: ./minishell
minishell> minishell> exit
Command 0:
  Arg 0: exit
fred@fred-virtualbox:~/code/minishell/ajamshid$

lancer un minishell dans un minishell

exit devrait exit que le minishell dans le minishell
----
variable d'environ
explications
global ?



si tu exit il faut : rl_clear_history();


export a voir

ctrl-\ 

Try ctrl-C after running a blocking command like cat or grep without arguments

export
unset

long commands


remove limit ?

typedef struct s_commands
{
	int				status;
	t_env			*env;
	char			**command;
	t_fcommand		**fcommand;
	char			**td[2048];
	int				**pipe_fd;
	int				pipe_count;
}					t_commands;

tried 500params ok

set commands into child process

free


---

gere le cas $? utilisant la valeur de retour dans commands

retirer les quotes and backquotes apres c



logs:


minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
hello
hello
world
world
^C
minishell> minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
hello
hello
minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
hello
hello
minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
^\^\^\^\^\^\^C
minishell> minishell> grep abc
Command 0: grep
Command 1: abc


here work

Command 0:
  Arg 0: grep
  Arg 1: abc
^C
minishell> minishell> grep abc
Command 0: grep
Command 1: abc


here work

Command 0:
  Arg 0: grep
  Arg 1: abc
^\^\^\^C
minishell> minishell> grep abc
Command 0: grep
Command 1: abc


here work

Command 0:
  Arg 0: grep
  Arg 1: abc
^C
minishell> minishell> ./minishell
Command 0: ./minishell


here work

Command 0:
  Arg 0: ./minishell
minishell> ./minishell
Command 0: ./minishell


here work

Command 0:
  Arg 0: ./minishell
minishell> ls
Command 0: ls


here work

Command 0:
  Arg 0: ls
abc_testin  file1     libft     minishell  out   qbc_testin  t    test   test3        test_exp_variables.c
a.out       includes  makefile  notes.txt  out1  src         tes  test2  test_exp2.c
minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
abc
abc
minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
^\

minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
wer
wer
qwe
qwe
minishell> cat
Command 0: cat


here work

Command 0:
  Arg 0: cat
qwwe
qwwe
asd
asd
^C

minishell> 
minishell> minishell> minishell> exit
Command 0: exit


here work

Command 0:
  Arg 0: exit
minishell> exit
Command 0: exit


here work

Command 0:
  Arg 0: exit
minishell> exit
Command 0: exit


here work

Command 0:
  Arg 0: exit


multiples heredoc too many \n 



minishell> cat << stop << stop2 <stop3
Error: File 'stop3' does not exist for input redirection
zsh: segmentation fault (core dumped)  ./minishell

made-f0Ar12s7% ./minishell
minishell> cat << stop << stop2
Command 0: cat
Command 1: <<
Command 2: stop
Command 3: <<
Command 4: stop2
> file1
> stop
> file2
> stop2
Command 0:
  Arg 0: cat
  Here Document:
file1

file2

file1

file2



quand le shell est bloque control c , ecrit minishell sur nouvelle ligne

main 

return 0 si control c , return status sinon.


./minishell                     
minishell> echo abc < not_found | echo test
Error: File 'not_found' does not exist for input redirection
free(): invalid pointer
zsh: IOT instruction (core dumped)  ./minishell



./minishell
minishell> echo abc < not_found | echo abc
Command 0: echo
Command 1: abc
Command 2: <
Command 3: not_found
Command 4: |
Command 5: echo
Command 6: abc
Command 0:
  Arg 0: echo
  Arg 1: abc
  Input Redirection: not_found
Command 1:
  Arg 0: echo
  Arg 1: abc
abc
